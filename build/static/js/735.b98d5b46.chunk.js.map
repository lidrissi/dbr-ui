{"version":3,"file":"static/js/735.b98d5b46.chunk.js","mappings":"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","sources":["api/node/node.js","components/Widget/Map/Map.jsx","helpers/map.js","components/Widget/Map/components/PolygonWrapper.jsx","components/Widget/Map/map.worker.js","components/Widget/Map/workerSetup.js","components/Widget/Tree/useNodeNotification.jsx","../node_modules/react-query/es/core/utils.js","../node_modules/react-query/es/core/notifyManager.js","../node_modules/react-query/es/react/reactBatchedUpdates.js","../node_modules/react-query/es/react/setBatchUpdatesFn.js","../node_modules/react-query/es/core/logger.js","../node_modules/react-query/es/react/logger.js","../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"],"sourcesContent":["import { useQuery, useMutation, useQueryClient } from 'react-query'\nimport axios from '../axios'\nimport { BACKEND_API_RESOURCES, getApiUrl } from 'constants/resources'\n\nexport function getWidgetNodes(widget) {\n\n  const options = {\n    method: BACKEND_API_RESOURCES.nodes.get.method,\n    url: `${getApiUrl()}/${BACKEND_API_RESOURCES.nodes.get.resource}?widget=${widget}`,\n  }\n\n  return axios(options)\n    .then((res) => {\n      return res.data\n    })\n    .catch((err) => {\n      return err\n    })\n}","import React, { useState, useEffect, useContext } from 'react'\nimport {\n  GoogleMap,\n  Marker,\n  InfoWindow,\n  KmlLayer,\n  useGoogleMap,\n  useLoadScript,\n} from '@react-google-maps/api'\nimport PropTypes from 'prop-types'\nimport mapWorker from './map.worker'\nimport WebWorker from './workerSetup'\nimport mapStyles from './mapStyles.json'\nimport { calculateMarkerBounds, calculatePolygonBounds } from '../../../helpers/map'\nimport PolygonWrapper from './components/PolygonWrapper'\nimport { getWidgetNodes } from '../../../api/node'\nimport useNodeNotification from '../Tree/useNodeNotification'\nimport { DbrContext } from '../../../services/context'\n\nconst defaultMapOptions = {\n  styles: mapStyles,\n  disableDefaultUI: true,\n  gestureHandling: 'auto',\n  mapTypeId: 'satellite',\n}\n\nlet listNode = {}\nlet Breadcrumb = []\nlet stratificationNodes = {}\n\nconst zoom = 5\nconst containerStyle = {\n  height: 'calc(100% - 42px)',\n  width: '100%',\n  borderRadius: '0 0 0.4rem 0.4rem',\n}\n\n/**\n * calculate bounds for google map\n * @param {*} positions\n */\nconst calculateBounds = (positions) => {\n  if (\n    positions &&\n    positions[0] &&\n    positions[0].polygonCoordinates &&\n    positions[0].polygonCoordinates.length > 0\n  ) {\n    return calculatePolygonBounds(positions)\n  }\n  return calculateMarkerBounds(positions)\n}\n\nconst getListNodeToshow = (currentNodesIds) => {\n\n  if (\n    !currentNodesIds ||\n    !currentNodesIds[0] ||\n    !(currentNodesIds[0] in listNode)\n  )\n    return\n\n  return currentNodesIds\n    .map((nodeId) => listNode[nodeId])\n    .flat()\n    .reduce((acc, node) => {\n      return acc.concat(node)\n    }, [])\n}\n\nlet map = null\n\nconst MapComponents = ({ handleMarkerClick, setBreadcrumb, getNodeAncestors, treeId }) => {\n  map = useGoogleMap()\n  const context = useContext(DbrContext)\n\n  const nodes = context?.map[treeId]?.mapNodes || []\n  const currentNodeId = context?.map[treeId]?.currentNodeId || null\n\n  const [infoVisibility, setInfoVisibility] = useState({})\n\n  useEffect(() => {\n    if (map && nodes) {\n      try {\n        map.fitBounds(calculateBounds(nodes))\n        if (nodes.length === 1 && nodes[0]?.kmzUrl) {\n          map.setZoom(map.getZoom() - 3)\n        }\n      } catch (e) {\n        mapContentKey = 'MAP_KEY_2'\n        console.log(\"error\", e);\n      }\n\n      setBreadcrumb(getNodeAncestors(currentNodeId))\n\n    }\n  }, [nodes]\n  )\n  const ShowKmlLayers = (node) => {\n    const kmlLayer = (\n      <KmlLayer\n        url={node.kmzUrl}\n        onClick={() => {\n          handleMarkerClick(node)\n        }}\n        options={{ preserveViewport: true, suppressInfoWindows: true }}\n      />\n    )\n    return kmlLayer\n  }\n\n  const ShowMarkers = (marker) => {\n    return (\n      <Marker\n        position={{ lat: marker.lat, lng: marker.lng }}\n        icon={marker.icon}\n        onClick={() => {\n          marker.setInfoVisibility({ [marker._id]: true })\n          handleMarkerClick(marker)\n        }}\n      >\n        {infoVisibility[marker._id] && <InfoWindow >\n          <h6>\n            {marker.name}\n          </h6>\n        </InfoWindow>}\n      </Marker>\n    )\n  }\n\n  const ShowPolygon = (marker) => (\n    <PolygonWrapper node={marker} handleMarkerClick={handleMarkerClick} />\n  )\n\n  const Markers = React.useMemo(() => {\n    return (\n      <>\n        {nodes &&\n          nodes.map((marker) => {\n            if (!marker) return null\n            if (\n              marker.polygonCoordinates &&\n              marker.polygonCoordinates.length > 0\n            ) {\n              return <ShowPolygon key={marker._id} {...marker} />\n            }\n            if (marker.kmzUrl) {\n              return <ShowKmlLayers key={marker._id} {...marker} />\n            }\n            return <ShowMarkers\n              key={marker._id}\n              {...marker}\n              infoVisibility={infoVisibility}\n              setInfoVisibility={setInfoVisibility}\n            />\n          })}\n      </>\n    )\n  }, [nodes])\n\n  return <>{Markers}</>\n}\n\nMapComponents.propTypes = {\n  handleMarkerClick: PropTypes.func,\n  nodes: PropTypes.array,\n  saveCurrentMapNodes: PropTypes.func,\n  setBreadcrumb: PropTypes.func,\n}\n\nconst MapBreadcrumb = ({\n  handleMarkerClick,\n  showNewStratificationOnMap,\n  rootNodesIds,\n  breadcrumb,\n}) => {\n  useEffect(() => {\n    showNewStratificationOnMap(rootNodesIds)\n  }, [rootNodesIds])\n\n  const onFirstBreadcrumbClick = React.useCallback(() => {\n    showNewStratificationOnMap('root')\n  }, [rootNodesIds])\n\n  // breadcrumb\n  Breadcrumb =\n    breadcrumb &&\n    breadcrumb.map((node, index) => {\n      if (breadcrumb.length - 1 === index) {\n        return (\n          <li key={Math.random()} className=\"breadcrumb-item-map active\">\n            <button\n              type=\"button\"\n              className=\"btn btn-sm btn-link\"\n              onClick={() => {\n                handleMarkerClick(node)\n              }}\n            >\n              {node.name || 'Unknown'}\n            </button>\n          </li>\n        )\n      }\n      return (\n        <li key={Math.random()} className=\"breadcrumb-item-map\">\n          <button\n            type=\"button\"\n            className=\"btn btn-sm btn-link\"\n            onClick={() => {\n              handleMarkerClick(node)\n            }}\n          >\n            {node.name || 'Unknown'}\n          </button>\n        </li>\n      )\n    })\n\n  return (\n    <ol className=\"breadcrumb bread-map\">\n      <li className=\"bread-map-left-icon\">\n        <i className=\"simple-icon-map\" />\n      </li>\n      <li className=\"breadcrumb-item-map-map\">\n        <button\n          type=\"button\"\n          className=\"btn btn-sm btn-link\"\n          onClick={onFirstBreadcrumbClick}\n        >\n          Home\n        </button>\n      </li>\n      {Breadcrumb}\n    </ol>\n  )\n}\n\nMapBreadcrumb.propTypes = {\n  breadcrumb: PropTypes.array,\n  handleMarkerClick: PropTypes.func,\n  rootNodesIds: PropTypes.oneOfType([PropTypes.string, PropTypes.array]),\n  showNewStratificationOnMap: PropTypes.func,\n}\n\nfunction MapHOC({ children, treeId, ...props }) {\n  const { setMapData } = useContext(DbrContext)\n\n  const getNodeAncestorsRecursive = (node, list) => {\n    if (!node) return\n    if (stratificationNodes[node.parent]) {\n      getNodeAncestorsRecursive(stratificationNodes[node.parent], list)\n    }\n    list.push(node)\n  }\n\n  const getNodeAncestors = (nodeId) => {\n    const bcrumb = []\n    getNodeAncestorsRecursive(stratificationNodes[nodeId], bcrumb)\n    return bcrumb\n  }\n\n  /**\n   * update Markers & trigger breadcrumb\n   * @param {*} currentNodeId\n   */\n  const updateMapMarkers = (currentNodesIds) => {\n    const flatenListNode = getListNodeToshow(currentNodesIds) || [\n      stratificationNodes?.[currentNodesIds],\n    ]\n    if (!flatenListNode || !flatenListNode[0]) return\n    if (currentNodesIds) {\n      setMapData(treeId, {\n        currentNodeId: currentNodesIds.length == 1 ? currentNodesIds[0] : 'root',\n        nodes: flatenListNode,\n        mapNodes: flatenListNode\n      })\n      props.setBreadcrumb(getNodeAncestors(currentNodesIds[0]))\n    }\n  }\n\n  const showNewStratificationOnMap = (nodeIds) => {\n    updateMapMarkers([].concat(nodeIds))\n  }\n\n  /**\n   * handle marker click\n   */\n  const handleMarkerClick = (marker) => {\n    if (marker && marker._id && marker.lat && marker.lng) {\n      showNewStratificationOnMap(marker._id)\n    }\n  }\n  return React.Children.map(children, (child) => {\n    const childProps = {\n      ...child.props,\n      handleMarkerClick,\n      showNewStratificationOnMap,\n      getNodeAncestors,\n      setBreadcrumb: props.setBreadcrumb\n    }\n    if (React.isValidElement(child)) {\n      return React.cloneElement(child, childProps)\n    }\n    return child\n  })\n}\n\nconst MAP_KEY = 'AIzaSyCzNqa1T_iZxs-eNClr8wyDIYzu3cdQs4Y'\nlet mapContentKey = 'MAP_KEY_1'\n\n// eslint-disable-next-line no-shadow\nfunction MapContent({\n  widget\n}) {\n  useNodeNotification({ widgetId: widget._id, treeId: widget.tree._id })\n\n  const [mapWorkerInstance] = useState(() => new WebWorker(mapWorker))\n  const { setMapData, ...other } = useContext(DbrContext)\n\n  console.log(\"====== other\", other);\n  const { isLoaded, loadError } = useLoadScript({\n    googleMapsApiKey: MAP_KEY,\n  })\n  const [center] = useState(() => ({\n    lat: 33.58831,\n    lng: -7.61138,\n  }))\n  const [rootNodesIds, setRootNodesIds] = useState()\n  const [breadcrumb, dispatchBreadcrumb] = React.useReducer(\n    (state, action) => action,\n    [],\n  )\n\n  const setInitialScope = (stratificationTree) => {\n    mapWorkerInstance.postMessage({\n      action: 'getNodesWithoutParent',\n      stratificationTree,\n    })\n    mapWorkerInstance.onmessage = (e) => {\n      const { action, nodesWithoutParent } = e.data\n\n      if (action === 'getNodesWithoutParent') {\n        const InitialRootNodesIds = nodesWithoutParent[0]\n          ? nodesWithoutParent\n          : stratificationTree &&\n          stratificationTree[0] &&\n          stratificationTree[0]._id\n        setRootNodesIds(InitialRootNodesIds)\n      }\n    }\n  }\n\n  const handleListStratification = (selfParentTree) => {\n    if (!selfParentTree || !Array.isArray(selfParentTree)) {\n      return\n    }\n    listNode = {}\n    stratificationNodes = {}\n    selfParentTree.forEach((node) => {\n      const parentId = node.parent || 'root'\n\n      if (!listNode[parentId]) {\n        listNode[parentId] = []\n      }\n      if (!node.location) {\n        return\n      }\n      const lat = node.location.coordinates[1]\n      const lng = node.location.coordinates[0]\n      // save node by id\n      stratificationNodes[node._id] = { ...node, lat, lng }\n\n      listNode[parentId].push({ ...node, lat, lng })\n    })\n    setInitialScope(selfParentTree)\n  }\n\n  useEffect(() => {\n    getWidgetNodes(widget.tree._id).then((data) => {\n      handleListStratification(data)\n      const nodesData = data.map(node => {\n        if (!node.location) {\n          return node\n        }\n        return ({\n          ...node,\n          lng: node.location.coordinates[0],\n          lat: node.location.coordinates[1]\n        })\n      })\n      console.log('========= nodesData', nodesData);\n\n      setMapData(widget.tree._id, { \"fati\": \"mmmmmm\" })\n    })\n  }, [])\n\n  if (loadError) {\n    return <div>Map cannot be loaded right now, sorry.</div>\n  }\n\n  return (\n    <div style={{ height: '100%' }}>\n      <MapHOC setBreadcrumb={dispatchBreadcrumb} treeId={widget.tree._id}>\n        <MapBreadcrumb rootNodesIds={rootNodesIds} breadcrumb={breadcrumb} />\n      </MapHOC>\n      {isLoaded ? (\n        <GoogleMap\n          id=\"startification-map\"\n          key={mapContentKey}\n          mapContainerStyle={containerStyle}\n          center={center}\n          zoom={zoom}\n          options={defaultMapOptions}\n        >\n          <MapHOC setBreadcrumb={dispatchBreadcrumb} treeId={widget.tree._id}>\n            <MapComponents treeId={widget.tree._id} />\n          </MapHOC>\n        </GoogleMap>\n      ) : (\n        <div className=\"loading\" />\n      )}\n    </div>\n  )\n}\n\nexport default MapContent\n","const calculateMarkerBounds = (positions) => {\n  if (!positions || !positions[0]) return undefined\n  const bounds = new window.google.maps.LatLngBounds()\n  for (let i = 0; i < positions.length; i++) {\n    const latLng = new window.google.maps.LatLng(\n      positions[i].lat,\n      positions[i].lng,\n    )\n    bounds.extend(latLng)\n  }\n  return bounds\n}\n\nconst calculatePolygonBounds = (listNode) => {\n\n  if (!listNode) return undefined\n  const bounds = new window.google.maps.LatLngBounds()\n  listNode.forEach(({ polygonCoordinates }) => {\n    for (let i = 0; i < polygonCoordinates.length; i++) {\n      const latLng = new window.google.maps.LatLng(\n        polygonCoordinates[i].lat || polygonCoordinates[i][1],\n        polygonCoordinates[i].lng || polygonCoordinates[i][0],\n      )\n      bounds.extend(latLng)\n    }\n  })\n  return bounds\n}\n\nexport { calculateMarkerBounds, calculatePolygonBounds }\n","import React, { useState } from 'react'\nimport { Polygon } from '@react-google-maps/api'\nimport PropTypes from 'prop-types'\n\nconst options = {\n  fillOpacity: 0.4,\n  strokeColor: '#000',\n  strokeOpacity: 1,\n  strokeWeight: 1,\n}\n\nfunction PolygonWrapper(props) {\n  const { node, handleMarkerClick } = props\n  const [fillColor, setFillColor] = useState(node.fillColor || '#000')\n\n  const handleMouseOver = () => {\n    setFillColor('#e9e7a8')\n  }\n\n  const handleMouseOut = () => {\n    setFillColor(node.fillColor || '#000')\n  }\n\n  const polygonOptions = { ...options, fillColor }\n\n  PolygonWrapper.propTypes = {\n    node: PropTypes.object,\n    handleMarkerClick: PropTypes.func,\n  }\n\n\n  const coords = node.polygonCoordinates.map(l => ({ lat: l[1], lng: l[0] }))\n\n  return (\n    <Polygon\n      paths={coords}\n      onClick={() => {\n        handleMarkerClick(node)\n      }}\n      onMouseOver={handleMouseOver}\n      onMouseOut={handleMouseOut}\n      options={polygonOptions}\n    />\n  )\n}\n\nexport default PolygonWrapper\n","export default function () {\n  onmessage = (e) => {\n    const { action, stratificationTree } = e.data\n    if (action === 'getNodesWithoutParent') {\n      // eslint-disable-next-line no-use-before-define\n      const nodesWithoutParent = getNodesWithoutParent(stratificationTree)\n      postMessage({ action, nodesWithoutParent })\n    }\n  }\n\n  let getNodesWithoutParent = (stratificationTree) => {\n    const nodesIds = stratificationTree.map(({ _id }) => _id)\n    const nodesWithoutParent = stratificationTree\n      .filter(({ parent }) => {\n        return !nodesIds.includes(parent)\n      })\n      .map(({ parent }) => parent)\n\n    return nodesWithoutParent\n  }\n}\n","export default class WebWorker {\n  constructor(worker) {\n    const code = worker.toString()\n    const blob = new Blob([`(${code})()`])\n    return new Worker(URL.createObjectURL(blob))\n  }\n}\n","import { useContext, useEffect } from 'react'\nimport { BACKEND_SOCKET_API_URL } from 'constants/resources';\nimport io from 'socket.io-client'\n// import { saveCurrentMapNodes } from 'widgets/Map/map.actions';\nimport { notificationService } from '../../../services/NotificationService';\nimport { DbrContext } from '../../../services/context';\n\nconst useNodeNotification = ({\n    widgetId,\n    treeId\n}) => {\n    let subscription;\n    let socket;\n\n    const { map, dashboard: { widgets }, setMapData } = useContext(DbrContext)\n\n    const id = treeId ? treeId : widgetId\n    const currentNodeId = map[id]?.currentNodeId || null\n    const data = map[id]?.data || []\n\n    useEffect(() => {\n        subscription = notificationService.getNotification().subscribe(notification => {\n            handleNotification(widgets, notification, data)\n        });\n\n        createSocket()\n        return () => {\n            if (subscription) {\n                subscription.unsubscribe();\n            }\n        }\n    }, [data, widgets])\n\n    useEffect(() => {\n        if (!currentNodeId) {\n            return\n        }\n        const node = data.find(({ _id }) => currentNodeId == _id)\n        if (!node) {\n            return\n        }\n        let appParamsValue = {}\n        for (let key in (node.metaData || {})) {\n            appParamsValue[key] = node.metaData[key] + ''.split(',').map(i => i.trim())[0]\n        }\n        if (node.applicationParam) {\n            appParamsValue[node.applicationParam] = node.name\n        }\n        if (Object.keys(appParamsValue)?.length > 0 && !(treeId && widgets[treeId])) {\n            notifyAllWidgets({\n                fromWidgetKey: widgetId,\n                appParamsValue\n            });\n        }\n    }, [currentNodeId])\n\n    const createSocket = (widgets) => {\n        socket = io(BACKEND_SOCKET_API_URL, {\n            path: '/back/socket',\n            transports: ['websocket', 'polling']\n        });\n\n        socket.on('connect', () => {\n            notificationService.registerWidgetSocket(socket);\n\n\n        });\n\n        socket.on(\"RECEIVE_NOTIFICATION\", (notification) => {\n            if (notification.widgetSocketId == socket.id) {\n                return\n            }\n            if (!notificationService.isWidgetRegistredInSocketPool(notification.widgetSocketId)) {\n                handleNotification(widgets, notification.widgetNotification, data);\n            }\n        });\n\n        return socket\n    }\n\n    const handleNotification = (widgets, notification, nodes) => {\n        if ((widgets && treeId && widgets[treeId]) || !notification.appParamsValue || notification.fromWidgetKey == widgetId) {\n            return\n        }\n\n        const appParams = notification.appParamsValue\n        const selectedNodes = nodes.filter(node => {\n            const commonKeys = Object.keys(appParams).filter(key => node.metaData && node.metaData[key])\n            return commonKeys?.length > 0 && commonKeys.every(key => {\n                return (node.metaData[key] &&\n                    (appParams[key] == '' || node.metaData[key].split(',').map(item => item.trim()).indexOf(appParams[key] + \"\") > -1))\n            })\n        })\n        if (selectedNodes?.length > 0) {\n            setMapData(treeId ? treeId : widgetId, {\n                currentNodeId: selectedNodes.length == 1 ? selectedNodes[0]._id : 'root',\n                mapNodes: selectedNodes,\n                nodes: selectedNodes\n            })\n        }\n    }\n\n    const notifyAllWidgets = (widgetNotification) => {\n        notificationService.sendNotification(widgetNotification);\n        if (!socket) {\n            socket = createSocket(widgets)\n        }\n        // notify others dashboards\n        socket.emit(\"SEND_NOTIFICATION\", { widgetSocketId: socket.id, widgetNotification: widgetNotification });\n    }\n\n    return {\n        currentNodeId,\n        notification: true\n    }\n};\n\nexport default useNodeNotification;","import _extends from \"@babel/runtime/helpers/esm/extends\";\n// TYPES\n// UTILS\nexport var isServer = typeof window === 'undefined';\nexport function noop() {\n  return undefined;\n}\nexport function functionalUpdate(updater, input) {\n  return typeof updater === 'function' ? updater(input) : updater;\n}\nexport function isValidTimeout(value) {\n  return typeof value === 'number' && value >= 0 && value !== Infinity;\n}\nexport function ensureQueryKeyArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\nexport function difference(array1, array2) {\n  return array1.filter(function (x) {\n    return array2.indexOf(x) === -1;\n  });\n}\nexport function replaceAt(array, index, value) {\n  var copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nexport function timeUntilStale(updatedAt, staleTime) {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);\n}\nexport function parseQueryArgs(arg1, arg2, arg3) {\n  if (!isQueryKey(arg1)) {\n    return arg1;\n  }\n\n  if (typeof arg2 === 'function') {\n    return _extends({}, arg3, {\n      queryKey: arg1,\n      queryFn: arg2\n    });\n  }\n\n  return _extends({}, arg2, {\n    queryKey: arg1\n  });\n}\nexport function parseMutationArgs(arg1, arg2, arg3) {\n  if (isQueryKey(arg1)) {\n    if (typeof arg2 === 'function') {\n      return _extends({}, arg3, {\n        mutationKey: arg1,\n        mutationFn: arg2\n      });\n    }\n\n    return _extends({}, arg2, {\n      mutationKey: arg1\n    });\n  }\n\n  if (typeof arg1 === 'function') {\n    return _extends({}, arg2, {\n      mutationFn: arg1\n    });\n  }\n\n  return _extends({}, arg1);\n}\nexport function parseFilterArgs(arg1, arg2, arg3) {\n  return isQueryKey(arg1) ? [_extends({}, arg2, {\n    queryKey: arg1\n  }), arg3] : [arg1 || {}, arg2];\n}\nexport function parseMutationFilterArgs(arg1, arg2) {\n  return isQueryKey(arg1) ? _extends({}, arg2, {\n    mutationKey: arg1\n  }) : arg1;\n}\nexport function mapQueryStatusFilter(active, inactive) {\n  if (active === true && inactive === true || active == null && inactive == null) {\n    return 'all';\n  } else if (active === false && inactive === false) {\n    return 'none';\n  } else {\n    // At this point, active|inactive can only be true|false or false|true\n    // so, when only one value is provided, the missing one has to be the negated value\n    var isActive = active != null ? active : !inactive;\n    return isActive ? 'active' : 'inactive';\n  }\n}\nexport function matchQuery(filters, query) {\n  var active = filters.active,\n      exact = filters.exact,\n      fetching = filters.fetching,\n      inactive = filters.inactive,\n      predicate = filters.predicate,\n      queryKey = filters.queryKey,\n      stale = filters.stale;\n\n  if (isQueryKey(queryKey)) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false;\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false;\n    }\n  }\n\n  var queryStatusFilter = mapQueryStatusFilter(active, inactive);\n\n  if (queryStatusFilter === 'none') {\n    return false;\n  } else if (queryStatusFilter !== 'all') {\n    var isActive = query.isActive();\n\n    if (queryStatusFilter === 'active' && !isActive) {\n      return false;\n    }\n\n    if (queryStatusFilter === 'inactive' && isActive) {\n      return false;\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false;\n  }\n\n  if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(query)) {\n    return false;\n  }\n\n  return true;\n}\nexport function matchMutation(filters, mutation) {\n  var exact = filters.exact,\n      fetching = filters.fetching,\n      predicate = filters.predicate,\n      mutationKey = filters.mutationKey;\n\n  if (isQueryKey(mutationKey)) {\n    if (!mutation.options.mutationKey) {\n      return false;\n    }\n\n    if (exact) {\n      if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {\n        return false;\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false;\n    }\n  }\n\n  if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {\n    return false;\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false;\n  }\n\n  return true;\n}\nexport function hashQueryKeyByOptions(queryKey, options) {\n  var hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;\n  return hashFn(queryKey);\n}\n/**\n * Default query keys hash function.\n */\n\nexport function hashQueryKey(queryKey) {\n  var asArray = ensureQueryKeyArray(queryKey);\n  return stableValueHash(asArray);\n}\n/**\n * Hashes the value into a stable hash.\n */\n\nexport function stableValueHash(value) {\n  return JSON.stringify(value, function (_, val) {\n    return isPlainObject(val) ? Object.keys(val).sort().reduce(function (result, key) {\n      result[key] = val[key];\n      return result;\n    }, {}) : val;\n  });\n}\n/**\n * Checks if key `b` partially matches with key `a`.\n */\n\nexport function partialMatchKey(a, b) {\n  return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));\n}\n/**\n * Checks if `b` partially matches with `a`.\n */\n\nexport function partialDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (typeof a !== typeof b) {\n    return false;\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return !Object.keys(b).some(function (key) {\n      return !partialDeepEqual(a[key], b[key]);\n    });\n  }\n\n  return false;\n}\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\n\nexport function replaceEqualDeep(a, b) {\n  if (a === b) {\n    return a;\n  }\n\n  var array = Array.isArray(a) && Array.isArray(b);\n\n  if (array || isPlainObject(a) && isPlainObject(b)) {\n    var aSize = array ? a.length : Object.keys(a).length;\n    var bItems = array ? b : Object.keys(b);\n    var bSize = bItems.length;\n    var copy = array ? [] : {};\n    var equalItems = 0;\n\n    for (var i = 0; i < bSize; i++) {\n      var key = array ? i : bItems[i];\n      copy[key] = replaceEqualDeep(a[key], b[key]);\n\n      if (copy[key] === a[key]) {\n        equalItems++;\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy;\n  }\n\n  return b;\n}\n/**\n * Shallow compare objects. Only works with objects that always have the same properties.\n */\n\nexport function shallowEqualObjects(a, b) {\n  if (a && !b || b && !a) {\n    return false;\n  }\n\n  for (var key in a) {\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n\n  return true;\n} // Copied from: https://github.com/jonschlinkert/is-plain-object\n\nexport function isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  } // If has modified constructor\n\n\n  var ctor = o.constructor;\n\n  if (typeof ctor === 'undefined') {\n    return true;\n  } // If has modified prototype\n\n\n  var prot = ctor.prototype;\n\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  } // If constructor does not have an Object-specific method\n\n\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false;\n  } // Most likely a plain Object\n\n\n  return true;\n}\n\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nexport function isQueryKey(value) {\n  return typeof value === 'string' || Array.isArray(value);\n}\nexport function isError(value) {\n  return value instanceof Error;\n}\nexport function sleep(timeout) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, timeout);\n  });\n}\n/**\n * Schedules a microtask.\n * This can be useful to schedule state updates after rendering.\n */\n\nexport function scheduleMicrotask(callback) {\n  Promise.resolve().then(callback).catch(function (error) {\n    return setTimeout(function () {\n      throw error;\n    });\n  });\n}\nexport function getAbortController() {\n  if (typeof AbortController === 'function') {\n    return new AbortController();\n  }\n}","import { scheduleMicrotask } from './utils'; // TYPES\n\n// CLASS\nexport var NotifyManager = /*#__PURE__*/function () {\n  function NotifyManager() {\n    this.queue = [];\n    this.transactions = 0;\n\n    this.notifyFn = function (callback) {\n      callback();\n    };\n\n    this.batchNotifyFn = function (callback) {\n      callback();\n    };\n  }\n\n  var _proto = NotifyManager.prototype;\n\n  _proto.batch = function batch(callback) {\n    this.transactions++;\n    var result = callback();\n    this.transactions--;\n\n    if (!this.transactions) {\n      this.flush();\n    }\n\n    return result;\n  };\n\n  _proto.schedule = function schedule(callback) {\n    var _this = this;\n\n    if (this.transactions) {\n      this.queue.push(callback);\n    } else {\n      scheduleMicrotask(function () {\n        _this.notifyFn(callback);\n      });\n    }\n  }\n  /**\n   * All calls to the wrapped function will be batched.\n   */\n  ;\n\n  _proto.batchCalls = function batchCalls(callback) {\n    var _this2 = this;\n\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      _this2.schedule(function () {\n        callback.apply(void 0, args);\n      });\n    };\n  };\n\n  _proto.flush = function flush() {\n    var _this3 = this;\n\n    var queue = this.queue;\n    this.queue = [];\n\n    if (queue.length) {\n      scheduleMicrotask(function () {\n        _this3.batchNotifyFn(function () {\n          queue.forEach(function (callback) {\n            _this3.notifyFn(callback);\n          });\n        });\n      });\n    }\n  }\n  /**\n   * Use this method to set a custom notify function.\n   * This can be used to for example wrap notifications with `React.act` while running tests.\n   */\n  ;\n\n  _proto.setNotifyFunction = function setNotifyFunction(fn) {\n    this.notifyFn = fn;\n  }\n  /**\n   * Use this method to set a custom function to batch notifications together into a single tick.\n   * By default React Query will use the batch function provided by ReactDOM or React Native.\n   */\n  ;\n\n  _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn) {\n    this.batchNotifyFn = fn;\n  };\n\n  return NotifyManager;\n}(); // SINGLETON\n\nexport var notifyManager = new NotifyManager();","import ReactDOM from 'react-dom';\nexport var unstable_batchedUpdates = ReactDOM.unstable_batchedUpdates;","import { notifyManager } from '../core';\nimport { unstable_batchedUpdates } from './reactBatchedUpdates';\nnotifyManager.setBatchNotifyFunction(unstable_batchedUpdates);","// TYPES\n// FUNCTIONS\nvar logger = console;\nexport function getLogger() {\n  return logger;\n}\nexport function setLogger(newLogger) {\n  logger = newLogger;\n}","export var logger = console;","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}"],"names":["getWidgetNodes","widget","options","method","BACKEND_API_RESOURCES","url","getApiUrl","axios","then","res","data","catch","err","defaultMapOptions","styles","mapStyles","disableDefaultUI","gestureHandling","mapTypeId","listNode","Breadcrumb","stratificationNodes","containerStyle","height","width","borderRadius","calculateBounds","positions","polygonCoordinates","length","bounds","window","google","maps","LatLngBounds","forEach","i","latLng","LatLng","lat","lng","extend","calculatePolygonBounds","calculateMarkerBounds","map","MapComponents","handleMarkerClick","setBreadcrumb","getNodeAncestors","treeId","useGoogleMap","context","useContext","DbrContext","nodes","mapNodes","currentNodeId","useState","infoVisibility","setInfoVisibility","useEffect","fitBounds","kmzUrl","setZoom","getZoom","e","mapContentKey","console","log","ShowKmlLayers","node","onClick","preserveViewport","suppressInfoWindows","ShowMarkers","marker","position","icon","_id","name","ShowPolygon","PolygonWrapper","Markers","React","MapBreadcrumb","showNewStratificationOnMap","rootNodesIds","breadcrumb","onFirstBreadcrumbClick","index","className","type","Math","random","MapHOC","children","props","setMapData","getNodeAncestorsRecursive","list","parent","push","nodeId","bcrumb","updateMapMarkers","currentNodesIds","flatenListNode","flat","reduce","acc","concat","getListNodeToshow","nodeIds","child","childProps","useNodeNotification","widgetId","tree","WebWorker","mapWorker","mapWorkerInstance","other","useLoadScript","googleMapsApiKey","isLoaded","loadError","center","setRootNodesIds","state","action","dispatchBreadcrumb","handleListStratification","selfParentTree","stratificationTree","Array","isArray","parentId","location","coordinates","postMessage","onmessage","nodesWithoutParent","InitialRootNodesIds","nodesData","style","id","mapContainerStyle","zoom","fillOpacity","strokeColor","strokeOpacity","strokeWeight","fillColor","setFillColor","polygonOptions","coords","l","paths","onMouseOver","onMouseOut","getNodesWithoutParent","nodesIds","filter","includes","worker","code","toString","blob","Blob","Worker","URL","createObjectURL","subscription","socket","widgets","dashboard","notificationService","subscribe","notification","handleNotification","createSocket","unsubscribe","find","appParamsValue","key","metaData","split","trim","applicationParam","Object","keys","notifyAllWidgets","fromWidgetKey","io","BACKEND_SOCKET_API_URL","path","transports","on","widgetSocketId","widgetNotification","appParams","selectedNodes","commonKeys","every","item","indexOf","emit","scheduleMicrotask","callback","Promise","resolve","error","setTimeout","NotifyManager","this","queue","transactions","notifyFn","batchNotifyFn","_proto","prototype","batch","result","flush","schedule","_this","batchCalls","_this2","_len","arguments","args","_key","apply","_this3","setNotifyFunction","fn","setBatchNotifyFunction","notifyManager","unstable_batchedUpdates","ReactDOM","logger","_objectWithoutProperties","source","excluded","target","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","call"],"sourceRoot":""}